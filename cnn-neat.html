<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Invaders - CNN-NEAT (Full Topology)</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <style>
        body { margin: 0; padding: 10px; display: flex; flex-direction: column; align-items: center; background-color: #111; color: #fff; font-family: 'Courier New', Courier, monospace; }
        #main-container { display: flex; flex-direction: row; gap: 20px; align-items: flex-start; }
        #controls { margin-bottom: 10px; display: flex; flex-direction: column; gap: 10px; align-items: center; width: 100%; }
        .control-row { display: flex; flex-wrap: wrap; justify-content: center; gap: 15px; align-items: center; }
        #controls button { padding: 10px 20px; font-size: 16px; background-color: #3f3; border: 2px solid #3f3; color: #000; cursor: pointer; box-shadow: 0 0 10px #3f3; }
        #info { font-size: 18px; }
        .slider-container { display: flex; align-items: center; gap: 5px; font-size: 14px; }
        #game-grid { display: grid; gap: 15px; grid-template-columns: repeat(4, 1fr); }
        .game-instance { position: relative; }
        .game-instance canvas { border: 1px solid #3f3; display: block; image-rendering: pixelated; }
        .instance-overlay { position: absolute; top: 5px; left: 5px; color: #3f3; font-size: 12px; pointer-events: none; }
        #visualization-container { padding: 10px; border: 2px solid #3f3; background-color: #000; box-shadow: 0 0 15px #3f3; width: 400px; }
        #visualization-container h3 { text-align: center; margin-top: 0; }
        #network-stats { margin-top: 15px; font-size: 14px; white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="controls">
        <div class="control-row">
            <button onclick="startTraining()">Start Training</button>
            <button onclick="pauseTraining()">Pause/Resume</button>
            <div id="info">
                <span>GEN: <span id="generation-count">0</span></span> |
                <span>BEST: <span id="best-fitness">0</span></span> |
                <span>SPECIES: <span id="species-count">0</span></span> |
                <span>TIME: <span id="time-limit">25</span>s</span>
            </div>
        </div>
        <div class="control-row">
             <div class="slider-container">
                 <label for="gameSpeed">Game Speed:</label>
                <input type="range" id="gameSpeed" min="1" max="100" step="1" value="1" oninput="updateGAVars()">
                <span id="gameSpeedValue">1</span>
            </div>
             <div class="slider-container">
                 <label for="layerParamMutationChance">Layer Param Mut. %:</label>
                <input type="range" id="layerParamMutationChance" min="0" max="1" step="0.01" value="0.3" oninput="updateGAVars()">
                <span id="layerParamMutationChanceValue">0.30</span>
            </div>
            <div class="slider-container">
                 <label for="topologyMutationChance">Topology Mut. %:</label>
                <input type="range" id="topologyMutationChance" min="0" max="0.5" step="0.01" value="0.1" oninput="updateGAVars()">
                <span id="topologyMutationChanceValue">0.10</span>
            </div>
        </div>
    </div>
    <div id="main-container">
        <div id="game-grid"></div>
        <div id="visualization-container">
            <h3>All-Time Best Architecture</h3>
            <svg id="network-svg" width="400" height="400"></svg>
            <div id="network-stats">
                <p>Initializing...</p>
            </div>
        </div>
    </div>

    <script>
        // --- Config ---
        let POPULATION_SIZE = 20;
        let gameSpeed = 1;
        const FPS = 60;
        const IMG_WIDTH = 40;
        const IMG_HEIGHT = 30;
        const COMPATIBILITY_THRESHOLD = 1.2;

        // Mutation rates (will be controlled by sliders)
        let MUTATE_WEIGHT_CHANCE = 0.8;
        let MUTATE_LAYER_PARAM_CHANCE = 0.3;
        let ADD_LAYER_CHANCE = 0.1;
        let REMOVE_LAYER_CHANCE = 0.05;

        // --- Global Vars ---
        let population;
        let gameInstances = [];
        let animationFrameId;
        let isPaused = false;
        let generation = 0;
        let generationFrames = 0;
        let generationTimeLimit = 25;

        // --- Core Game Logic ---
        class Game {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d', { willReadFrequently: true });
                this.init();
            }

            init() {
                this.player = { x: 200 / 2 - 12.5, y: 150 - 30, width: 25, height: 15, lives: 3 };
                this.invaders = []; this.projectiles = []; this.alienProjectiles = []; this.barriers = [];
                this.fitness = 0; this.frames = 0; this.enemiesKilled = 0; this.framesIdle = 0; this.gameOver = false;
                this.win = false; this.invaderDirection = 1; this.invaderSpeed = 0.25;
                for (let r = 0; r < 3; r++) { for (let c = 0; c < 5; c++) { this.invaders.push({ x: c * 30 + 30, y: r * 20 + 20, width: 20, height: 15 }); } }
                for (let i = 0; i < 4; i++) { const bX = i * 45 + 20; for (let j = 0; j < 9; j++) { this.barriers.push({ x: bX + (j % 3) * 5, y: 150 - 45 + Math.floor(j / 3) * 5, width: 5, height: 5, health: 4 }); } }
            }

            update(action) {
                if (this.gameOver) return;
                this.frames++;
                if (action === 'stay') this.framesIdle++;
                if (action === 'left') this.player.x -= 5;
                if (action === 'right') this.player.x += 5;
                if (action === 'shoot' && this.projectiles.length < 3) {
                    this.projectiles.push({ x: this.player.x + this.player.width / 2 - 2.5, y: this.player.y, speed: -5, hit: false });
                }
                this.player.x = Math.max(0, Math.min(200 - this.player.width, this.player.x));
                this.projectiles.forEach((p, i) => { p.y += p.speed; if (p.y < 0 && !p.hit) { this.fitness -= 2; this.projectiles.splice(i, 1); } });
                this.alienProjectiles.forEach((p, i) => {
                    const oY = p.y;
                    p.y += p.speed;
                    if (oY < this.player.y && p.y >= this.player.y) { this.fitness += 0.5; }
                    if (p.y > 150) { this.alienProjectiles.splice(i, 1); }
                });
                let hE = false;
                this.invaders.forEach(inv => { inv.x += this.invaderSpeed * this.invaderDirection; if (inv.x <= 0 || inv.x + inv.width >= 200) hE = true; if (inv.y + inv.height >= this.player.y) this.endGame(); if (Math.random() < 0.004) { this.alienProjectiles.push({ x: inv.x + inv.width / 2, y: inv.y + inv.height, speed: 2.5 }); } });
                if (hE) { this.invaderDirection *= -1; this.invaders.forEach(inv => inv.y += 5); }
                this.projectiles.forEach((p, pi) => {
                    if (p.hit) return;
                    this.invaders.forEach((inv, ii) => { if (this.isColliding(p, inv)) { p.hit = true; this.projectiles.splice(pi, 1); this.invaders.splice(ii, 1); this.enemiesKilled++; this.fitness += 5; } });
                    this.barriers.forEach(b => { if (b.health > 0 && this.isColliding(p, b)) { p.hit = true; this.projectiles.splice(pi, 1); b.health--; } });
                });
                this.alienProjectiles.forEach((p, pi) => {
                    if (this.isColliding(p, this.player)) { this.alienProjectiles.splice(pi, 1); this.player.lives--; this.fitness -= 20; if (this.player.lives <= 0) this.endGame(); return; }
                    this.barriers.forEach(b => { if (b.health > 0 && this.isColliding(p, b)) { this.alienProjectiles.splice(pi, 1); b.health--; } });
                });
                if (this.invaders.length === 0) {
                    this.win = true;
                    this.endGame();
                }
            }

            calculateFinalFitness() {
                const stats = { enemies_killed: this.enemiesKilled, level_reached: this.win ? 1 : 0, frames_survived: this.frames, frames_idle: this.framesIdle, lives_lost: 3 - this.player.lives, };
                const w = { K: 2.0, L: 10.0, T: 0.05, M: 0.001, D: 5.0 };
                const finalBonus = (w.K * stats.enemies_killed + w.L * stats.level_reached + w.T * stats.frames_survived - w.M * stats.frames_idle - w.D * stats.lives_lost);
                this.fitness += finalBonus;
                this.fitness = Math.max(0, Math.min(this.fitness, 10000));
            }

            draw() {
                this.ctx.fillStyle = '#000'; this.ctx.fillRect(0, 0, 200, 150);
                this.ctx.fillStyle = '#3f3'; this.ctx.fillRect(this.player.x, this.player.y, this.player.width, this.player.height);
                this.ctx.fillStyle = '#f0f'; this.invaders.forEach(i => this.ctx.fillRect(i.x, i.y, i.width, i.height));
                this.barriers.forEach(b => { if (b.health > 0) { this.ctx.fillStyle = `rgba(63, 255, 63, ${b.health * 0.25})`; this.ctx.fillRect(b.x, b.y, b.width, b.height); } });
                this.ctx.fillStyle = '#ff0'; this.projectiles.forEach(p => this.ctx.fillRect(p.x, p.y, 5, 10));
                this.ctx.fillStyle = '#ff4500'; this.alienProjectiles.forEach(p => this.ctx.fillRect(p.x, p.y, 5, 10));
                
                if(this.gameOver) {
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; this.ctx.fillRect(0, 0, 200, 150); this.ctx.textAlign = 'center';
                    if (this.win) { this.ctx.fillStyle = '#3f3'; this.ctx.font = '32px "Courier New", Courier, monospace'; this.ctx.fillText('YOU WIN', 100, 80); }
                    else { this.ctx.fillStyle = 'red'; this.ctx.font = '24px "Courier New", Courier, monospace'; this.ctx.fillText('GAME OVER', 100, 80); }
                }
            }
            isColliding(a, b) { if (!a || !b) return false; return a.x < b.x + b.width && a.x + (a.width || 5) > b.x && a.y < b.y + b.height && a.y + (a.height || 10) > b.y; }
            endGame() { if (this.gameOver) return; this.gameOver = true; this.calculateFinalFitness(); }
        }
        
        // --- CNN-NEAT Implementation ---
        class LayerGene {
            constructor(type, params) { this.type = type; this.params = params; }
            clone() { return new LayerGene(this.type, { ...this.params }); }
        }

        class Genome {
            constructor(existingGenome) {
                this.layerGenes = []; this.model = null; this.fitness = 0;
                if (existingGenome) { this.layerGenes = existingGenome.layerGenes.map(lg => lg.clone()); }
                else {
                    this.layerGenes.push(new LayerGene('conv2d', { filters: 4, kernelSize: 3, activation: 'relu' }));
                    this.layerGenes.push(new LayerGene('flatten', {}));
                    this.layerGenes.push(new LayerGene('dense', { units: 3, activation: 'softmax' }));
                }
            }
            buildModel() {
                if (this.model) this.model.dispose(); this.model = tf.sequential(); this.model.add(tf.layers.inputLayer({ inputShape: [IMG_HEIGHT, IMG_WIDTH, 1] }));
                for (const layerGene of this.layerGenes) {
                    try {
                        if(layerGene.type === 'conv2d' || layerGene.type === 'maxPooling2d'){ const lastShape = this.model.layers[this.model.layers.length -1].outputShape; if (Array.isArray(lastShape) && lastShape.length === 4) { const inputH = lastShape[1] || 2; const inputW = lastShape[2] || 2; layerGene.params.kernelSize = Math.min(layerGene.params.kernelSize || 2, inputH, inputW); if (layerGene.params.kernelSize < 1) { layerGene.params.kernelSize = 1; } } }
                        this.model.add(tf.layers[layerGene.type](layerGene.params));
                    } catch (e) {
                        console.error("Error building model with layer:", layerGene, e); this.model.dispose(); this.model = tf.sequential(); this.model.add(tf.layers.inputLayer({inputShape: [IMG_HEIGHT, IMG_WIDTH, 1]})); this.model.add(tf.layers.flatten({})); this.model.add(tf.layers.dense({units: 3, activation: 'softmax'})); break;
                    }
                }
            }
            predict(inputs) { if (!this.model) this.buildModel(); const actions = ['left', 'right', 'shoot']; return tf.tidy(() => { const output = this.model.predict(inputs); const actionIndex = output.argMax(-1).dataSync()[0]; return actions[actionIndex]; }); }
            dispose() { if (this.model) this.model.dispose(); }
        }

        class Population {
            constructor(size) { this.genomes = []; for (let i = 0; i < size; i++) { this.genomes.push(new Genome()); } this.species = []; this.allTimeBestGenome = null; this.nextSpeciesId = 0; }
            async evolve() {
                await this.speciate();
                const sortedGenomes = [...this.genomes].sort((a, b) => b.fitness - a.fitness);
                if (!this.allTimeBestGenome || sortedGenomes[0].fitness > this.allTimeBestGenome.fitness) { this.allTimeBestGenome = new Genome(sortedGenomes[0]); this.allTimeBestGenome.fitness = sortedGenomes[0].fitness; drawNetworkArchitecture(this.allTimeBestGenome); }
                document.getElementById('best-fitness').textContent = this.allTimeBestGenome.fitness.toFixed(0);
                const newGeneration = [];
                if (this.allTimeBestGenome) { const elite = new Genome(this.allTimeBestGenome); elite.buildModel(); newGeneration.push(elite); }
                while (newGeneration.length < POPULATION_SIZE) {
                    const species = this.selectSpecies();
                    if (!species || species.members.length === 0) { const randomGenome = this.genomes[Math.floor(Math.random() * this.genomes.length)]; newGeneration.push(new Genome(randomGenome)); continue; };
                    const parent1 = this.selectParent(species);
                    const parent2 = this.selectParent(species);
                    const child = this.crossover(parent1, parent2);
                    this.mutate(child);
                    newGeneration.push(child);
                }
                this.genomes.forEach(g => g.dispose());
                this.genomes = newGeneration;
                generation++;
                document.getElementById('generation-count').textContent = generation;
                document.getElementById('species-count').textContent = this.species.length;
            }
            async speciate() { for (const s of this.species) { s.members = []; } for (const genome of this.genomes) { let foundSpecies = false; for (const s of this.species) { const distance = this.calculateDistance(genome, s.representative); if (distance < COMPATIBILITY_THRESHOLD) { s.members.push(genome); foundSpecies = true; break; } } if (!foundSpecies) { this.species.push({ id: this.nextSpeciesId++, representative: new Genome(genome), members: [genome] }); } } this.species = this.species.filter(s => s.members.length > 0); for (const s of this.species) { s.representative = new Genome(s.members[Math.floor(Math.random() * s.members.length)]); } }
            calculateDistance(g1, g2) { let d=0; d+=Math.abs(g1.layerGenes.length-g2.layerGenes.length)*0.5; const len=Math.min(g1.layerGenes.length, g2.layerGenes.length); for(let i=0;i<len;i++){ const l1=g1.layerGenes[i]; const l2=g2.layerGenes[i]; if(l1.type!==l2.type){d+=1}else{if(l1.type==='conv2d'||l1.type==='maxPooling2d'){d+=Math.abs((l1.params.filters||0)-(l2.params.filters||0))/16;d+=Math.abs((l1.params.kernelSize||l1.params.poolSize||0)-(l2.params.kernelSize||l2.params.poolSize||0))/4}else if(l1.type==='dense'){d+=Math.abs(l1.params.units-l2.params.units)/64}}} return d; }
            crossover(p1, p2) { const child = new Genome(); child.layerGenes = []; const len = Math.min(p1.layerGenes.length, p2.layerGenes.length); for (let i = 0; i < len; i++) { child.layerGenes.push(Math.random() < 0.5 ? p1.layerGenes[i].clone() : p2.layerGenes[i].clone()); } if (p1.layerGenes.length > len) { for (let i = len; i < p1.layerGenes.length; i++) { child.layerGenes.push(p1.layerGenes[i].clone()); } } return child; }
            
            mutate(genome) {
                if (genome.model && Math.random() < MUTATE_WEIGHT_CHANCE) { tf.tidy(() => { const newWeights = []; for (const weight of genome.model.getWeights()) { const shape = weight.shape; const oldValues = weight.dataSync(); const newValues = new Float32Array(oldValues.length); for (let i = 0; i < oldValues.length; i++) { if (Math.random() < 0.1) { newValues[i] = oldValues[i] + (Math.random() * 0.4 - 0.2); } else { newValues[i] = oldValues[i]; } } newWeights.push(tf.tensor(newValues, shape)); } genome.model.setWeights(newWeights); newWeights.forEach(w => w.dispose()); }); }
                if (Math.random() < MUTATE_LAYER_PARAM_CHANCE) {
                    const layerIndex = Math.floor(Math.random() * genome.layerGenes.length);
                    const layerGene = genome.layerGenes[layerIndex];
                    if (layerGene.type === 'conv2d') { if (Math.random() < 0.5) { layerGene.params.filters = Math.max(1, layerGene.params.filters + (Math.random() < 0.5 ? -1 : 1)); } else { const newSize = layerGene.params.kernelSize + (Math.random() < 0.5 ? -1 : 1); layerGene.params.kernelSize = Math.max(1, Math.min(newSize, 5)); } }
                    else if (layerGene.type === 'dense' && layerGene.params.units && layerGene.params.activation !== 'softmax') { layerGene.params.units = Math.max(2, layerGene.params.units + (Math.random() < 0.5 ? -2 : 2)); }
                    else if (layerGene.type === 'maxPooling2d') { const newSize = layerGene.params.poolSize[0] + (Math.random() < 0.5 ? -1 : 1); layerGene.params.poolSize = [Math.max(1,newSize), Math.max(1,newSize)]; }
                    if (layerGene.params.activation && layerGene.params.activation !== 'softmax') { if (Math.random() < 0.2) { layerGene.params.activation = ['relu', 'tanh', 'sigmoid'][Math.floor(Math.random() * 3)]; } }
                }
                
                if (Math.random() < ADD_LAYER_CHANCE) {
                    const flattenIndex = genome.layerGenes.findIndex(lg => lg.type === 'flatten');
                    if (flattenIndex === -1) return;
                    const addConv = Math.random() < 0.5;
                    if (addConv) {
                        const insertIndex = Math.floor(Math.random() * (flattenIndex + 1));
                        const choice = Math.random();
                        let newLayer;
                        if (choice < 0.6) newLayer = new LayerGene('conv2d', { filters: 4, kernelSize: 3, activation: 'relu' });
                        else if (choice < 0.8) newLayer = new LayerGene('maxPooling2d', { poolSize: [2, 2], strides: [2, 2] });
                        else newLayer = new LayerGene('batchNormalization', {});
                        genome.layerGenes.splice(insertIndex, 0, newLayer);
                    } else {
                        const finalLayerIndex = genome.layerGenes.length - 1;
                        const insertStartIndex = flattenIndex + 1;
                        if (insertStartIndex < finalLayerIndex) { const insertIndex = insertStartIndex + Math.floor(Math.random() * (finalLayerIndex - insertStartIndex)); const newLayer = new LayerGene('dense', { units: 16, activation: 'relu' }); genome.layerGenes.splice(insertIndex, 0, newLayer); }
                    }
                }

                if (genome.layerGenes.length > 3 && Math.random() < REMOVE_LAYER_CHANCE) { const removeIndex = Math.floor(Math.random() * (genome.layerGenes.length - 2)) + 1; if (genome.layerGenes[removeIndex].type !== 'flatten') { genome.layerGenes.splice(removeIndex, 1); } }
            }

            selectSpecies() { const totalFitness = this.species.reduce((s, sp) => s + sp.members.reduce((ss, m) => ss + Math.max(0, m.fitness), 0), 0); if (totalFitness <= 0) return this.species[0]; let r = Math.random() * totalFitness; for (const s of this.species) { for (const m of s.members) { r -= Math.max(0, m.fitness); if (r <= 0) return s } } return this.species[0]; }
            selectParent(species) { const totalFitness = species.members.reduce((s, m) => s + Math.max(0, m.fitness), 0); if (totalFitness <= 0) return species.members[0]; let r = Math.random() * totalFitness; for (const m of species.members) { r -= Math.max(0, m.fitness); if (r <= 0) return m } return species.members[0]; }
        }

        // --- Main Control Loop ---
        function runGeneration() {
            let updatesThisFrame = 0;
            const updatesPerFrame = gameSpeed > 10 ? Math.floor(gameSpeed / 10) : 1;
            function singleFrame() {
                if (isPaused) { animationFrameId = requestAnimationFrame(singleFrame); return; }
                for (let i = 0; i < updatesPerFrame; i++) {
                    generationFrames++;
                    let allGamesOver = true;
                    for (let j = 0; j < POPULATION_SIZE; j++) { const game = gameInstances[j]; const genome = population.genomes[j]; if (game.gameOver) continue; allGamesOver = false; const inputs = getGameInputs(game); const action = genome.predict(inputs); inputs.dispose(); game.update(action); }
                    if ((generationFrames / FPS) > generationTimeLimit) { gameInstances.forEach(game => { if (!game.gameOver) game.endGame(); }); }
                    if (allGamesOver) { endGeneration(); return; }
                }
                for (let i = 0; i < POPULATION_SIZE; i++) { gameInstances[i].draw(); const overlay = document.getElementById(`overlay-${i}`); overlay.textContent = `Fitness: ${gameInstances[i].fitness.toFixed(0)} | Lives: ${gameInstances[i].player.lives}`; }
                if (gameSpeed > 10 && updatesThisFrame * updatesPerFrame < gameSpeed) { updatesThisFrame++; setTimeout(singleFrame, 0); }
                else { animationFrameId = requestAnimationFrame(singleFrame); }
            }
            singleFrame();
        }
        
        async function endGeneration() {
            cancelAnimationFrame(animationFrameId);
            for (let i = 0; i < POPULATION_SIZE; i++) { if(!gameInstances[i].gameOver) gameInstances[i].endGame(); population.genomes[i].fitness = gameInstances[i].fitness; }
            await population.evolve();
            generationFrames = 0;
            generationTimeLimit += 5;
            document.getElementById('time-limit').textContent = generationTimeLimit;
            for (let i = 0; i < POPULATION_SIZE; i++) { gameInstances[i].init(); }
            runGeneration();
        }

        function getGameInputs(game) { return tf.tidy(() => { const pixelData = game.ctx.getImageData(0, 0, 200, 150); let tensor = tf.browser.fromPixels(pixelData, 1); tensor = tf.image.resizeBilinear(tensor, [IMG_HEIGHT, IMG_WIDTH]); tensor = tensor.div(255.0); return tensor.expandDims(0); }); }
        
        // --- UI & Visualization ---
        function drawNetworkArchitecture(genome) {
            const svg = document.getElementById('network-svg');
            const stats = document.getElementById('network-stats');
            svg.innerHTML = '';
            
            const width = svg.clientWidth;
            const layerHeight = 45;
            const layerGap = 15;
            const totalHeight = genome.layerGenes.length * (layerHeight + layerGap);
            svg.setAttribute('height', totalHeight > 0 ? totalHeight : 50);

            let yOffset = layerHeight / 2;

            genome.layerGenes.forEach((lg, i) => {
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', 10);
                rect.setAttribute('y', yOffset - layerHeight/2);
                rect.setAttribute('width', width - 20);
                rect.setAttribute('height', layerHeight);
                rect.setAttribute('rx', 5);
                rect.setAttribute('ry', 5);
                
                const text1 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text1.setAttribute('x', width / 2);
                text1.setAttribute('y', yOffset - 5);
                text1.setAttribute('text-anchor', 'middle');
                text1.setAttribute('fill', 'white');
                text1.setAttribute('font-size', '14px');
                text1.textContent = lg.type.toUpperCase();
                
                const text2 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text2.setAttribute('x', width / 2);
                text2.setAttribute('y', yOffset + 15);
                text2.setAttribute('text-anchor', 'middle');
                text2.setAttribute('fill', 'lightgray');
                text2.setAttribute('font-size', '12px');
                
                if (lg.type === 'conv2d') { rect.setAttribute('fill', '#2980B9'); text2.textContent = `filters: ${lg.params.filters}, kernel: ${lg.params.kernelSize}, act: ${lg.params.activation}`; }
                else if (lg.type === 'maxPooling2d') { rect.setAttribute('fill', '#C0392B'); text2.textContent = `pool: [${lg.params.poolSize}]`; }
                else if (lg.type === 'batchNormalization') { rect.setAttribute('fill', '#F1C40F'); text1.setAttribute('y', yOffset + 5); }
                else if (lg.type === 'flatten') { rect.setAttribute('fill', '#27AE60'); text1.setAttribute('y', yOffset + 5); }
                else if (lg.type === 'dense') { rect.setAttribute('fill', '#8E44AD'); text2.textContent = `units: ${lg.params.units}, act: ${lg.params.activation}`; }
                
                g.appendChild(rect);
                g.appendChild(text1);
                if (text2.textContent) g.appendChild(text2);
                svg.appendChild(g);

                if (i > 0) {
                    const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    const startY = yOffset - layerHeight/2 - layerGap;
                    const endY = yOffset - layerHeight/2;
                    arrow.setAttribute('d', `M ${width/2} ${startY + 5} v ${layerGap - 10}`);
                    arrow.setAttribute('stroke', '#fff');
                    arrow.setAttribute('stroke-width', '2');
                    arrow.setAttribute('marker-end', 'url(#arrowhead)');
                    svg.appendChild(arrow);
                }

                yOffset += layerHeight + layerGap;
            });

            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
            marker.setAttribute('id', 'arrowhead'); marker.setAttribute('viewBox', '0 -5 10 10'); marker.setAttribute('refX', 5); marker.setAttribute('refY', 0); marker.setAttribute('markerWidth', 4); marker.setAttribute('markerHeight', 4); marker.setAttribute('orient', 'auto');
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', 'M0,-5L10,0L0,5'); path.setAttribute('fill', '#fff');
            marker.appendChild(path); defs.appendChild(marker); svg.appendChild(defs);

            let html = `<p>Best Fitness: ${genome.fitness.toFixed(0)}</p><p>--- Architecture ---</p>`;
            genome.layerGenes.forEach((lg, i) => { html += `<p>Layer ${i}: ${lg.type}`; if (lg.type === 'conv2d') { html += ` | f: ${lg.params.filters}, k: ${lg.params.kernelSize}, a: ${lg.params.activation}`; } else if (lg.type === 'dense' && lg.params.units) { html += ` | u: ${lg.params.units}, a: ${lg.params.activation}`; } html += `</p>`; });
            stats.innerHTML = html;
        }

        function updateGAVars() {
            gameSpeed = parseInt(document.getElementById('gameSpeed').value);
            document.getElementById('gameSpeedValue').textContent = gameSpeed;
            MUTATE_LAYER_PARAM_CHANCE = parseFloat(document.getElementById('layerParamMutationChance').value);
            document.getElementById('layerParamMutationChanceValue').textContent = MUTATE_LAYER_PARAM_CHANCE.toFixed(2);
            const topologyChance = parseFloat(document.getElementById('topologyMutationChance').value);
            ADD_LAYER_CHANCE = topologyChance;
            REMOVE_LAYER_CHANCE = topologyChance / 2; // Keep remove chance lower
            document.getElementById('topologyMutationChanceValue').textContent = topologyChance.toFixed(2);
        }

        function setupUI() {
            const g=document.getElementById('game-grid');
            g.innerHTML='';
            g.style.gridTemplateColumns=`repeat(4, 1fr)`;
            updateGAVars();
            document.getElementById('time-limit').textContent=generationTimeLimit;
            for(let i=0;i<POPULATION_SIZE;i++){
                const d=document.createElement('div');
                d.className='game-instance';
                const c=document.createElement('canvas');
                c.width=200;
                c.height=150;
                const o=document.createElement('div');
                o.className='instance-overlay';
                o.id=`overlay-${i}`;
                o.textContent='Fitness: 0 | Lives: 3';
                d.appendChild(c);
                d.appendChild(o);
                g.appendChild(d);
                gameInstances.push(new Game(c));
            }
        }

        async function startTraining() {
            if (animationFrameId) { cancelAnimationFrame(animationFrameId); }
            isPaused = false;
            generation = 0;
            generationFrames = 0;
            generationTimeLimit = 25;
            population = new Population(POPULATION_SIZE);
            gameInstances = [];
            setupUI();
            drawNetworkArchitecture(population.genomes[0]);
            runGeneration();
        }

        function pauseTraining() { isPaused = !isPaused; }
        window.onload = () => { tf.ready().then(() => { population = new Population(POPULATION_SIZE); setupUI(); }); };
    </script>
</body>
</ht